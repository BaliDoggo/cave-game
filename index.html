<!DOCTYPE html>

<html>

<head>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.js"></script>
    <style media='screen' type='text/css'>
      @font-face {
        font-family: handwritten;
        src: url('assets/fonts/Alkhemikal.ttf');
        font-weight:400;
        font-weight:normal;
      }
</style>
</head>

<body>
    <div style="font-family:font1; position:absolute; left:-1000px; visibility:hidden;">.</div>
    <script>

        

        var gui;
        var guiTimer;
        var overlay;
        var overlayVisible;
        var backgroundMusic;

          class Playertd extends Phaser.Physics.Arcade.Sprite
                   {
                       totalJumps = 2;
                       currentJumps = 0;
                       constructor(scene, x, y)
                       {
                           super(scene, x, y, 'player');
                           scene.add.existing(this);
                           scene.physics.add.existing(this);
                           this.setScale(1);
                           this.setCollideWorldBounds(true);
                           this.setGravityY(0); //We will set gravity *per object* rather than for the scene!
                       }
                   }


        class PhysicsSprite extends Phaser.Physics.Arcade.Sprite {
        }

        var config = {
            type: Phaser.AUTO,
            width: 1600,
            height: 800,
            physics: {
                default: 'arcade',
            arcade: {
                debug: true
            }
            },
            scene: {
                preload: preload,
                create: create,
                update: update,
            }
        };
        
        class Player extends Phaser.Physics.Arcade.Sprite {  
            animations;
            constructor(scene, x, y, spritesheet, animations) {
                super(scene, x, y, spritesheet);
                this.animations = animations;
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setScale(0.5);
                this.setCollideWorldBounds(true)
                this.setGravityY(1500)
                this.setBounce(0, 0)
            }
        }
        
        class Platform extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, image) {
                super(scene, x, y, image);
                scene.add.existing(this);
                scene.physics.add.existing(this);
                this.setCollideWorldBounds(true)
                this.setGravityY(0)
                this.setBounce(0, 0)
                this.bodyType = 1
                this.body.setSize(80, 80)
                
            }
        }
        
        class Level extends Phaser.Physics.Arcade.Sprite {
            constructor(scene, x, y, image) {
                super(scene, x, y, image);
                scene.add.existing(this)
                scene.physics.add.existing(this)
                this.setCollideWorldBounds(false)
                this.setGravity(0, 0)
                this.bodyType = 1
            }
        }

        var game = new Phaser.Game(config);
        
        const delay = ms => new Promise(res => setTimeout(res, ms));


        var caveTeleporter;
        var player;
        var platforms;
        var platform;

        var carrots = [];
    var totalCarrots = 12;
        
        var switch1;
        var keys;
        var cursors;
        var scene;
        
        var graphics;
        
        var jump;
        var coins;
        var timer;
        
        var current_level;
        var climb;
        var mine = false;
        
        

        function preload () {
            this.load.image('crystal', 'assets/cave/crystal.png')
            this.load.image('cave_background', 'assets/cave/cave_background.png');
            this.load.image('cave_ground', 'assets/cave/cave_ground.png');
            this.load.image('lava', 'assets/cave/lava.png'); 
            this.load.audio('cave_song', 'assets/cave/cave_song.m4a');
            this.load.image('block', 'assets/cave/block.png');
            this.load.image('cave_teleporter', 'assets/cave/cave_teleporter.png'); 
            this.load.image('stalagmite1', 'assets/cave/cave_smites_1.png');
            this.load.image('stalactite', 'assets/cave/cave_stites_1.png'); 
            this.load.image('stalagmite2', 'assets/cave/cave_smites_2.png'); 
            this.load.atlas('player', 'assets/player/player.png', 'assets/player/player.json');
            this.load.image('player_old', 'assets/player/player_idle.png');
            this.load.image('platform', 'assets/platform.png');
            this.load.tilemapTiledJSON('level_1', 'assets/cave/levels/level_1.json')
            this.load.image('lobby', 'assets/lobby.png');
                       this.load.image('playertd', 'assets/playerf1.png');
                       this.load.image('playerr1', 'assets/playerr1.png');
                       this.load.image('playerl1', 'assets/playerl1.png');
                       this.load.image('playerb1', 'assets/playerb1.png');
                       this.load.image('playerf2', 'assets/playerf2.png');
                       this.load.image('playerf3', 'assets/playerf3.png');
                       this.load.image('playerr2', 'assets/playerr2.png');
                       this.load.image('playerr3', 'assets/playerr3.png');
                       this.load.image('playerl2', 'assets/playerl2.png');
                       this.load.image('playerl3', 'assets/playerl3.png');
                       this.load.image('playerb2', 'assets/playerb2.png');
                       this.load.image('playerb3', 'assets/playerb3.png');
                       this.load.image('overlay', 'assets/upgrade.png');
                       this.load.image('shop', 'assets/shop.png');
                       this.load.image('guild', 'assets/guild.png');
                       this.load.image('teleporter', 'assets/teleporter.png');
                       this.load.audio('backgroundMusic', 'assets/backgroundMusic.mp3');
                       this.load.image('stonepick', 'assets/stonepick.png');
        }

        function create () {
            backgroundMusic = this.sound.add('backgroundMusic', { volume: 1.5, loop: true });
            backgroundMusic.play();
            lobby.call(this)
            switch1 = this.input.keyboard.addKey('Q');
            switch2 = this.input.keyboard.addKey('P');
            keys = this.input.keyboard.addKeys('W, A, S, D, M, F, SHIFT');
            
            graphics = this.add.graphics()
        }

        function update() {
            if (switch1.isDown) {  
                levelOne.call(this);  
            }

            if (switch2.isDown) {  
                levelTwo.call(this);  
            }
            
            if (scene === 'levelOne'){
                
                //console.log('o')
                
                //this.cameras.main.setPosition(-player.x+400, 0)-
                let direction;
                
                if (game.input.activePointer.isDown) {
                    var mine = true
                    player.setVelocityX(0)
                } else {
                    mine = false
                }

                if (mine && direction === 'left') {
                    player.play(player.animations['mine_l'], true)
                } else if (mine) {
                    player.play(player.animations['mine_r'], true)
                }
                
                if (keys.W.isDown && jump === true){
                    player.setVelocityY(-600)
                    jump = false
                }
                
                

                if (keys.A.isDown){
                    player.setVelocityX(-250)
                    player.play(player.animations['run_l'], true);
                    direction = 'left'
                } else if (keys.D.isDown){
                    player.setVelocityX(250)
                    player.play(player.animations['run_r'], true);
                    direction = 'right'
                } else if (direction === 'left' && !game.input.activePointer.isDown) {
                    player.setVelocityX(0)
                    player.play(player.animations['idle_l'], true);
                
                }else if (!game.input.activePointer.isDown && direction === 'right'){
                    player.setVelocityX(0)
                    player.play(player.animations['idle_r'], true);
                } else if (!game.input.activePointer.isDown) {
                    player.setVelocityX(0)
                    player.play(player.animations['idle_l'], true);
                } else if (direction === 'left') {
                    player.play(player.animations['mine_l'], true)
                } else if (direction === 'right') {
                    player.play(player.animations['mine_r'], true)
                }
            
                
                if (keys.S.isDown){
                    return
                }
                
                if (player.body.onFloor()) {
                    jump = true
                } else {
                    jump = false
                }
                
                if (player.body.blocked.right) {
                    climb = true
                } else if (player.body.blocked.left) {
                    climb = true
                } else {
                    climb = false
                }
                
                if (player.body.blocked.left && keys.SHIFT.isDown) {
                    player.setVelocityY(-100)
                    player.setVelocityX(-10)
                    player.play(player.animations['climb_l'], true);
                } else if (player.body.blocked.right && keys.SHIFT.isDown) {
                    player.setVelocityY(-100)
                    player.setVelocityX(10)
                    player.play(player.animations['climb_r'], true);
            }
            
                
            }
            
            if (scene === 'lobby'){
                 resizeGame(800,800);
                    if (player.x > 500 && player.x < 750 && player.y > 50 && player.y < 140) {
                    gui.setText('Press F to enter Blacksmith');
                        if (Phaser.Input.Keyboard.JustDown(keys.F)) {
                            toggleOverlay.call(this, 'overlay');
                        }    
                    guiTimer = this.time.delayedCall(1000, removeText, [], this);
                } else if (player.x > 50 && player.x < 200 && player.y > 50 && player.y < 150) {
                    gui.setText('Press F to enter Market');
                    if (Phaser.Input.Keyboard.JustDown(keys.F)) {
                        toggleOverlay.call(this, 'shop');
                    }
                    guiTimer = this.time.delayedCall(1000, removeText, [], this);
                } else if (player.x > 500 && player.x < 750 && player.y > 600 && player.y < 750) {
                    gui.setText('Press F to enter Miners Guild');
                    if (Phaser.Input.Keyboard.JustDown(keys.F)) {
                        toggleOverlay.call(this, 'guild');
                    }
                    guiTimer = this.time.delayedCall(1000, removeText, [], this);
                } else if (player.x > 340 && player.x < 460 && player.y > 340 && player.y < 450) {
                    gui.setText('Press F to enter Teleporter');
                    if (Phaser.Input.Keyboard.JustDown(keys.F)) {
                        toggleOverlay.call(this, 'teleporter');
                    }
                    guiTimer = this.time.delayedCall(1000, removeText, [], this);
                } else {
                    if (overlayVisible) {
                        overlay.destroy();
                        overlayVisible = false;
                    }
                }

                // Handle player movements
                player.setVelocityX(0);
                player.setDragX(1000);
                player.setDragY(1000);

                if (cursors.left.isDown || keys.A.isDown) {
                    player.setVelocityX(-100);
                    player.anims.play('left', true);
                } else if (cursors.right.isDown || keys.D.isDown) {
                    player.setVelocityX(100);
                    player.anims.play('right', true);
                } else if (cursors.up.isDown || keys.W.isDown) {
                    player.setVelocityY(-100);
                    player.anims.play('up', true);
                } else if (cursors.down.isDown || keys.S.isDown) {
                    player.setVelocityY(100);
                    player.anims.play('down', true);
                } else {
                    player.anims.stop();
                    player.setTexture('playertd'); // Replace 'player' with the default facing frame
                }
            }}

            function toggleOverlay(imageKey) {
                if (!overlayVisible) {
                    overlay = this.add.image(0, 0, imageKey).setOrigin(0);
                    overlay.setDepth(1); // Ensure overlay is above other game elements
                    overlayVisible = true;
                } else {
                    overlay.destroy(); // Remove the overlay from the scene
                    overlayVisible = false;
                }
            }

        function levelOne() {
            overlay.destroy(); // Remove the overlay from the scene
            overlayVisible = false;
            resizeGame(1600,800);
            scene = 'levelOne'
            console.log(scene)
            jump = true
            
            this.add.text(400, 400, 'argula', {fontFamily: 'handwritten',});

            background = this.add.tileSprite(800, 500, 1600, 800, 'cave_background').setScale(1.25);
            crystal = this.physics.add.image(1000, 600, 'crystal').setScale(0.25)
            let caveTeleporter = this.physics.add.image(1530, 410, 'cave_teleporter').setScale(0.2);

            let playerAnims = {};
            var idle_l = this.anims.create({key: 'idle_l', frames: this.anims.generateFrameNames('player', {prefix: 'idle_l', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['idle_l'] = idle_l
            var idle_r = this.anims.create({key: 'idle_r', frames: this.anims.generateFrameNames('player', {prefix: 'idle_r', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['idle_r'] = idle_r
            var run_l = this.anims.create({key: 'run_l', frames: this.anims.generateFrameNames('player', {prefix: 'run_l_', end: 3, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['run_l'] = run_l
            var run_r = this.anims.create({key: 'run_r', frames: this.anims.generateFrameNames('player', {prefix: 'run_r_', end: 3, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['run_r'] = run_r
            var crouch_r = this.anims.create({key: 'crouch_r', frames: this.anims.generateFrameNames('player', {prefix: 'crouch_r', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['crouch_r'] = crouch_r
            var crouch_l = this.anims.create({key: 'crouch_l', frames: this.anims.generateFrameNames('player', {prefix: 'crouch_l', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['crouch_l'] = crouch_l
            var climb_l = this.anims.create({key: 'climb_l', frames: this.anims.generateFrameNames('player', {prefix: 'climb_l_', end: 2, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['climb_l'] = climb_l
            var climb_r = this.anims.create({key: 'climb_r', frames: this.anims.generateFrameNames('player', {prefix: 'climb_r_', end: 2, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['climb_r'] = climb_r
            var mine_l = this.anims.create({key: 'mine_l', frames: this.anims.generateFrameNames('player', {prefix: 'mine_l_', end: 1, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['mine_l'] = mine_l
            var mine_r = this.anims.create({key: 'mine_r', frames: this.anims.generateFrameNames('player', {prefix: 'mine_r_', end: 1, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['mine_r'] = mine_r
            
            
            createLevel.call(this)
            
            player = new Player(this, 400, 0, 'player', playerAnims);
            this.physics.add.collider(player, platform);
            this.physics.add.collider(player, current_level);
            player.play(player.animations['idle_l']);
            
            //this.cameras.main.startFollow(player, true)
            
            this.physics.add.overlap(player, crystal, mineCrystal)
            this.physics.add.overlap(player, caveTeleporter, lobby, null, this);
        }
        
        function createLevel() {

            
            
            var map = this.make.tilemap({key: 'level_1' })
            
            var tileset = map.addTilesetImage('cave_ground')
            
            platform = this.physics.add.staticGroup();
            //floor
            platform.create(400, 800, 'cave_ground').setScale(1).refreshBody();
            platform.create(1200, 800, 'cave_ground').setScale(1).refreshBody();
            
            //level
            current_level = map.createLayer('level', tileset)
            current_level.setCollisionBetween(0, 199)
            //current_level = this.physics.add.staticGroup();
            //this.add.existing(current_level)
            //this.physics.add.existing(current_level)
            
        }

        function lobby() {
            if (scene === 'levelOne') {
                //caveTeleporter.destroy()
                player.destroy()
            }
            
            resizeGame(800,800);
            scene = 'lobby'
            let background = this.add.tileSprite(0, 0, game.scale.width, game.scale.height, 'lobby').setOrigin(0, 0);

           

                      player = new Playertd(this, 400, 400);


                      this.physics.add.overlap(player, null, this);

                      //Set up user input
                      cursors = this.input.keyboard.createCursorKeys();
                      keys = this.input.keyboard.addKeys('W, A, S, D, F');
                      

                      gui = this.add.text(0, 0, '', {fontSize: '45px', fill: '#fcfcfc'});


                       guiTimer = this.time.delayedCall(1000, removeText, [], this);


                       this.anims.create({
                       key: 'left',
                       frames: [
                           { key: 'playerl1' },
                           { key: 'playerl2' },
                           { key: 'playerl3' }
                       ],
                       frameRate: 10,
                       repeat: -1
                   });

                   this.anims.create({
                       key: 'right',
                       frames: [
                           { key: 'playerr1' },
                           { key: 'playerr2' },
                           { key: 'playerr3' }
                       ],
                       frameRate: 10,
                       repeat: -1
                   });

                   this.anims.create({
                       key: 'up',
                       frames: [
                           { key: 'playertd' },
                           { key: 'playerf2' },
                           { key: 'playerf3' }
                       ],
                       frameRate: 10,
                       repeat: -1
                   });

                    this.anims.create({
                       key: 'down',
                       frames: [
                           { key: 'playerb1' },
                           { key: 'playerb2' },
                           { key: 'playerb3' }
                       ],
                       frameRate: 10,
                       repeat: -1
                   });


                 
                       
                     this.input.on('pointermove', function (pointer) {
        });
        this.input.on('pointerdown', (pointer) => {
                if (overlayVisible && pointer.x >= 140 && pointer.x <= 669 && pointer.y >= 193 && pointer.y <= 246) {
                levelOne.call(this);
                }
            });               
                   
        }

        function levelTwo() {
            resizeGame(1600,800);
            scene = 'levelOne'
            jump = true
            
            console.log(scene)

            music = this.sound.add('cave_song'); 
            music.play({
                loop: true
            });

            this.add.image(400,700, 'cave_ground');

            this.platforms = this.physics.add.staticGroup();
            let ground = this.platforms.create(800, 700, 'cave_ground');
            ground.displayWidth = 1600;
            ground.refreshBody();


            background = this.add.tileSprite(800, 400, 1600, 800, 'cave_background');

            let lava = this.physics.add.image(600,561, 'lava');
            lava.body.setAllowGravity(false);
            lava.body.immovable = true;
            lava.setScale(2.2);

            let stalagmite1 = this.physics.add.image(300, 530, 'stalagmite1'); 
            stalagmite1.body.setAllowGravity(false);
            stalagmite1.body.immovable = true; 
            stalagmite1.setScale(0.2);
            stalagmite1.body.setScale(0.15)

            caveTeleporter = this.physics.add.image(1530, 480, 'cave_teleporter');
            caveTeleporter.body.setAllowGravity(false);
            caveTeleporter.body.immovable = true; 
            caveTeleporter.setScale(0.2);

            let block = this.platforms.create(600,500, 'block');
            block.setScale(0.5);
        
            let playerAnims = {};
            var idle_l = this.anims.create({key: 'idle_l', frames: this.anims.generateFrameNames('player', {prefix: 'idle_l', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['idle_l'] = idle_l
            var idle_r = this.anims.create({key: 'idle_r', frames: this.anims.generateFrameNames('player', {prefix: 'idle_r', end: 0, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['idle_r'] = idle_r
            var run_l = this.anims.create({key: 'run_l', frames: this.anims.generateFrameNames('player', {prefix: 'run_l_', end: 3, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['run_l'] = run_l
            var run_r = this.anims.create({key: 'run_r', frames: this.anims.generateFrameNames('player', {prefix: 'run_r_', end: 3, zeroPad: 1}), repeat: -1, frameRate: 10})
            playerAnims['run_r'] = run_r

            player = new Player(this, 100, 400, 'player', playerAnims);
            this.physics.add.collider(player, ground);
            player.play(player.animations['idle_l']);

            this.physics.world.setBounds(0,0,1600,800);

            this.physics.add.collider(player, block);
            this.physics.add.collider(player, lava, obstacleCollision, null, this);
            this.physics.add.collider(player, stalagmite1, obstacleCollision, null, this);
            this.physics.add.overlap(player, caveTeleporter, playerWin, null, this);
        }

        function eatCarrot(player, carrot)
    {
        carrot.disableBody(true, true); //remove that particular carrot from the game (physics and visibility)
        gui.setText('Yum yum!');
        guiTimer = this.time.delayedCall(1000, removeText, [], this);
    }

    function removeText()
    {
        gui.setText('');
    }

    

    function obstacleCollision(player, obstacle) {
            

            player.setVelocityX(0);
            player.setVelocityY(0);
            player.body.enable = false;

            const bannerWidth = 1600;
            const bannerHeight = 100;
            const bannerX = 800 - bannerWidth / 2;
            const bannerY = 400 - bannerHeight / 2;

            const graphics = this.add.graphics();
            graphics.fillStyle(0x000000, 0.5); 
            graphics.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);

            let gameOverText = this.add.text(800, 400, "GAME OVER", {
                fontSize: '64px',
                color: '#9e0b0b',
                fontFamily: 'Stencil Std',
            });
            gameOverText.setOrigin(0.5, 0.5);

            this.time.delayedCall(2000, () => {
                levelTwo.call(this);
            }, [], this);
        }

    function playerWin(player, teleporter) {
            const bannerWidth = 1600;
            const bannerHeight = 100;
            const bannerX = 800 - bannerWidth / 2;
            const bannerY = 400 - bannerHeight / 2;

            const graphics = this.add.graphics();
            graphics.fillStyle(0x000000, 0.5); 
            graphics.fillRect(bannerX, bannerY, bannerWidth, bannerHeight);

            let winText = this.add.text(800, 400, 'YOU WIN!', {
                fontSize: '64px',
                color: '#f5e410',
                fontFamily: 'Stencil Std',
            });
            winText.setOrigin(0.5, 0.5);
        }

    function resizeGame(width, height) {
        game.scale.resize(width, height);
    }

    const mineCrystal = async() => {
        
        if (crystal.visible && game.input.activePointer.isDown) {
        await delay(2000)
        if (crystal.visible && game.input.activePointer.isDown) {
        crystal.visible = false
        coins += 5
        console.log(coins)
        }
    }

    function setUp() {
        backgroundMusic.stop();
        caveTeleporter.destroy()
        player.destroy()
        lobby
    }
         

    };
   

        
        
    </script>
</body>

</html>
